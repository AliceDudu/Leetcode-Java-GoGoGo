题目要求，从左上走到右下，1代表墙，0代表路，求最短路径

例如给的这个例子，
00点出发，环顾四周，只有下面可以走，画出一棵树的树杈来
10出发，环顾四周，只有下面可以走，画出一棵树的树杈来
。。。
这样可以画出一棵树

要找00～44的最短路径
可以用bfs来扫这棵树，一层一层扫，每一层记录一个步长
当第一次遇到44时，就得到了最短路径长度

所以代码的话：（yes即由上部分描述，需要的变量）
counter用来记录步长，一层算一步～yes
boolean 矩阵用来记录都有哪些点已经被访问过了，走过了就不能再走了
需要一个queue来保存同一层可以走的点，即可以走的可能性～yes

每个点需要走四个方向，需要一个direction的数组，来保存四个方向～yes

start code：
第一步，00被加入到q中，加入后就把visitied相应位置标记为true
接着，从q中弹出当前层可以走的点，同一层，一共可以走size个可能，走之前先将counter＋1
一个一个走，即00
每个点可以沿着4个方向走，
一个一个方向走，用00加上其中一个方向后
先看是否得到了end点，得到的话就返回counter
没有的话，如果visited了，就略过
没有visited，就把这个点加入到q中，下一层待用

time：O（direction^depth）
space：O（m＊n）


